<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MIDI Music Theory Visualizer</title>
    <script src="https://cdn.jsdelivr.net/npm/midi-parser-js@4.0.4/src/main.js"></script>
    <style>
        :root {
            --theme-color: #00ffcc;
            --theme-color-rgb: 0, 255, 204;
        }
        
        * {
            box-sizing: border-box;
        }
        
        body {
            font-family: Arial, sans-serif;
            background: linear-gradient(to bottom, #1a1a1a, #2c3e50);
            color: #fff;
            margin: 0;
            padding: 0;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }
        
        .container {
            max-width: 1200px;
            width: 100%;
            margin: 20px auto;
            padding: 20px;
            flex: 1;
        }
        
        h1 {
            text-align: center;
            color: var(--theme-color);
            text-shadow: 0 0 10px rgba(var(--theme-color-rgb), 0.5);
            margin: 20px 0;
            font-size: 2em;
            background: #111;
            padding: 15px;
            border-radius: 4px;
        }
        
        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            justify-content: center;
            flex-wrap: nowrap;
            overflow-x: auto;
            padding: 5px 0;
        }
        
        select, input[type="color"], button, input[type="file"] {
            padding: 10px 15px;
            font-size: 14px;
            border: none;
            border-radius: 5px;
            background: #3a3a3a;
            color: #e0e0e0;
            cursor: pointer;
            transition: background 0.3s ease, transform 0.1s ease;
            font-family: inherit;
            white-space: nowrap;
            flex-shrink: 0;
        }
        
        select:hover, button:hover {
            background: #4a4a4a;
        }
        
        button:active {
            transform: scale(0.95);
        }
        
        button.active {
            background: var(--theme-color);
            color: #1a1a1a;
            font-weight: bold;
        }
        
        input[type="color"] {
            width: 50px;
            height: 40px;
            padding: 5px;
        }
        
        input[type="file"] {
            display: none;
        }
        
        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 20px;
            justify-content: center;
            align-items: center;
            background: #222;
            padding: 15px;
            border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }d-control {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        input[type="range"] {
            width: 150px;
            height: 6px;
            border-radius: 3px;
            background: #4a4a4a;
            outline: none;
            -webkit-appearance: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--theme-color);
            cursor: pointer;
        }
        
        input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--theme-color);
            cursor: pointer;
            border: none;
        }
        
          .midi-info {
            background: #333;
            padding: 10px;
            border-radius: 4px;
            border: 1px solid #444;
            height: 150px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            line-height: 1.6;
        } line-height: 1.6;
        }
        
        .midi-info::-webkit-scrollbar {
            width: 8px;
        }
        
        .midi-info::-webkit-scrollbar-track {
            background: #2a2a2a;
            border-radius: 4px;
        }
        
        .midi-info::-webkit-scrollbar-thumb {
            background: var(--theme-color);
            border-radius: 4px;
        }
        
        .canvas-container {
            margin-top: 20px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            align-items: center;
        }
        
        .canvas-wrapper {
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .canvas-label {
            font-size: 16px;
            color: var(--theme-color);
            margin-bottom: 10px;
            font-weight: 500;
        }
        
        canvas {
            background: #fff;
            border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            max-width: 100%;
            height: auto;
            border: 1px solid #444;
        }
        
        .status-message {
            text-align: center;
            padding: 15px;
            background: #282828;
            border-radius: 4px;
            margin-bottom: 20px;
            color: var(--theme-color);
            border: 1px solid #444;
        }
        
        .hidden {
            display: none;
        }
        
        @media (max-width: 600px) {
            .container {
                padding: 15px;
            }
            
            h1 {
                font-size: 22px;
            }
            
            .controls {
                flex-direction: column;
                align-items: stretch;
            }
            
            select, button {
                width: 100%;
            }
            
            .playback-controls {
                flex-direction: column;
            }
            
            .speed-control {
                width: 100%;
                justify-content: space-between;
            }
            
            input[type="range"] {
                flex: 1;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>MIDI Music Theory Visualizer</h1>
        
        <div class="controls">
            <button id="uploadBtn">üìÅ Upload MIDI</button>
            <input type="file" id="fileInput" accept=".mid,.midi">
            <select id="sampleSelect">
                <option value="">Select Sample MIDI</option>
                <option value="cmajor">C Major Scale</option>
                <option value="blues">Blues Riff</option>
                <option value="arpeggio">Basic Arpeggio</option>
                <optgroup label="Guitar Practice">
                    <option value="guitarCMajArp">Guitar: C Major Arpeggio</option>
                    <option value="guitarGMajArp">Guitar: G Major Arpeggio</option>
                </optgroup>
                <optgroup label="Piano Practice">
                    <option value="pianoCMaj7Arp">Piano: C Major 7 Arpeggio</option>
                    <option value="pianoAMinArp">Piano: A Minor Arpeggio</option>
                </optgroup>
                <optgroup label="Bass Practice">
                    <option value="bassCMajArp">Bass: C Major Arpeggio</option>
                    <option value="bassFunkLine">Bass: Funk Line</option>
                </optgroup>
                <optgroup label="Ukulele Practice">
                    <option value="ukuleleCMajArp">Ukulele: C Major Arpeggio</option>
                    <option value="ukuleleFMajArp">Ukulele: F Major Arpeggio</option>
                </optgroup>
                <optgroup label="Classical Pieces">
                    <option value="toccata">Toccata and Fugue in D Minor</option>
                    <option value="bumblebee">Flight of the Bumblebee</option>
                </optgroup>
            </select>
            <select id="notationSelect">
                <option value="sharp">Sharps</option>
                <option value="flat">Flats</option>
            </select>
            <select id="tuningSelect">
                <option value="standard">Guitar: Standard Tuning</option>
                <option value="dropd">Guitar: Drop D Tuning</option>
                <option value="openg">Guitar: Open G Tuning</option>
                <option value="dadgad">Guitar: DADGAD Tuning</option>
                <option value="bass4">Bass: 4-String Standard</option>
                <option value="bass5">Bass: 5-String Standard</option>
                <option value="ukulele">Ukulele: Standard (High G)</option>
                <option value="ukuleleLowG">Ukulele: Low G Tuning</option>
            </select>
            <select id="stringOrderSelect">
                <option value="lowBottom" selected>Low String Bottom</option>
                <option value="highBottom">High String Bottom</option>
            </select>
            <select id="fretViewSelect">
                <option value="all">All Frets (0-12)</option>
                <option value="above6">Above Fret 6 (7-12)</option>
                <option value="range6-13">Frets 6-13</option>
                <option value="0-6">Frets 0-6 Only</option>
                <option value="extended">Extended (0-23 Frets)</option>
            </select>
            <select id="duplicateFilterSelect">
                <option value="all">Show All Positions</option>
                <option value="unique">Show Unique Only</option>
            </select>
            <input type="color" id="themeColor" value="#00ffcc" title="Theme Color">
            <button onclick="window.open('theory-reference.html', '_blank')">üìö Theory Reference</button>
        </div>
        
        <div class="playback-controls">
            <button id="showAllBtn" disabled>üëÅÔ∏è Show All Notes</button>
            <button id="playBtn" disabled>‚ñ∂ Play</button>
            <button id="pauseBtn" disabled>‚è∏ Pause</button>
            <button id="stopBtn" disabled>‚èπ Stop</button>
            <button id="loopBtn" disabled>üîÅ Loop</button>
            <button id="stepBackBtn" disabled>‚èÆÔ∏è Step Back</button>
            <button id="stepForwardBtn" disabled>‚è≠Ô∏è Step Forward</button>
            <div class="speed-control">
                <label>Speed:</label>
                <input type="range" id="speedSlider" min="0.1" max="2" step="0.1" value="1" disabled>
                <span id="speedDisplay">1.0x</span>
            </div>
        </div>
        
        <div class="status-message" id="statusMessage">
            Upload a MIDI file or select a sample to begin
        </div>
        
        <div class="midi-info" id="midiInfo"></div>
        
        <div class="canvas-container">
            <div class="canvas-wrapper">
                <div class="canvas-label" id="fretboardLabel">Guitar Fretboard</div>
                <canvas id="fretboardCanvas" width="800" height="300"></canvas>
            </div>
            <div class="canvas-wrapper">
                <div class="canvas-label">Piano Roll</div>
                <canvas id="pianoCanvas" width="840" height="120"></canvas>
            </div>
        </div>
    </div>

    <script>
        // Configuration
        const tunings = {
            standard: [40, 45, 50, 55, 59, 64], // E2 A2 D3 G3 B3 E4 (Guitar)
            dropd: [38, 45, 50, 55, 59, 64],    // D2 A2 D3 G3 B3 E4 (Guitar)
            openg: [38, 43, 50, 55, 59, 62],    // D2 G2 D3 G3 B3 D4 (Guitar)
            dadgad: [38, 45, 50, 55, 57, 62],   // D2 A2 D3 G3 A3 D4 (Guitar)
            bass4: [28, 33, 38, 43],            // E1 A1 D2 G2 (4-String Bass)
            bass5: [23, 28, 33, 38, 43],        // B0 E1 A1 D2 G2 (5-String Bass)
            ukulele: [67, 60, 64, 69],          // G4 C4 E4 A4 (Ukulele High G)
            ukuleleLowG: [55, 60, 64, 69]       // G3 C4 E4 A4 (Ukulele Low G)
        };
        
        const sharpNotes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
        const flatNotes = ['C', 'Db', 'D', 'Eb', 'E', 'F', 'Gb', 'G', 'Ab', 'A', 'Bb', 'B'];
        
        // State
        let midiNotes = [];
        let playbackTimer = null;
        let playbackTime = 0;
        let isPlaying = false;
        let isLooping = false;
        let currentStepIndex = 0; // For step-through mode
        let currentTuning = tunings.standard;
        let currentNotation = 'sharp';
        let currentStringOrder = 'lowBottom';
        let currentFretView = 'all'; // Fret view mode
        let currentDuplicateFilter = 'all'; // Duplicate filter mode
        let themeColor = '#00ffcc';
        let activeNotes = new Set();
        let noteIntensity = {}; // For heat map coloring
        
        // Audio context for playback
        let audioContext = null;
        let audioEnabled = true;
        
        // DOM Elements
        const uploadBtn = document.getElementById('uploadBtn');
        const fileInput = document.getElementById('fileInput');
        const sampleSelect = document.getElementById('sampleSelect');
        const showAllBtn = document.getElementById('showAllBtn');
        const playBtn = document.getElementById('playBtn');
        const pauseBtn = document.getElementById('pauseBtn');
        const stopBtn = document.getElementById('stopBtn');
        const loopBtn = document.getElementById('loopBtn');
        const stepBackBtn = document.getElementById('stepBackBtn');
        const stepForwardBtn = document.getElementById('stepForwardBtn');
        const speedSlider = document.getElementById('speedSlider');
        const speedDisplay = document.getElementById('speedDisplay');
        const midiInfo = document.getElementById('midiInfo');
        const statusMessage = document.getElementById('statusMessage');
        const fretboardCanvas = document.getElementById('fretboardCanvas');
        const fretboardLabel = document.getElementById('fretboardLabel');
        const pianoCanvas = document.getElementById('pianoCanvas');
        const notationSelect = document.getElementById('notationSelect');
        const tuningSelect = document.getElementById('tuningSelect');
        const stringOrderSelect = document.getElementById('stringOrderSelect');
        const fretViewSelect = document.getElementById('fretViewSelect');
        const duplicateFilterSelect = document.getElementById('duplicateFilterSelect');
        const themeColorInput = document.getElementById('themeColor');
        
        // Utility Functions
        function noteToName(noteNumber, notation = 'sharp') {
            const noteNames = notation === 'sharp' ? sharpNotes : flatNotes;
            const octave = Math.floor(noteNumber / 12) - 1;
            const note = noteNames[noteNumber % 12];
            return `${note}${octave}`;
        }
        
        function isNoteInRange(noteNumber) {
            // Check if note can be played on current instrument tuning
            const numFrets = currentFretView === 'extended' ? 23 : 12;
            const minNote = Math.min(...currentTuning);
            const maxNote = Math.max(...currentTuning) + numFrets;
            return noteNumber >= minNote && noteNumber <= maxNote;
        }
        
        function getNoteRangeWarning(noteNumber) {
            const numFrets = currentFretView === 'extended' ? 23 : 12;
            const minNote = Math.min(...currentTuning);
            const maxNote = Math.max(...currentTuning) + numFrets;
            
            if (noteNumber < minNote) {
                return `‚ö†Ô∏è Note too low for current instrument (min: ${noteToName(minNote, currentNotation)})`;
            } else if (noteNumber > maxNote) {
                return `‚ö†Ô∏è Note too high for current instrument (max: ${noteToName(maxNote, currentNotation)})`;
            }
            return null;
        }
        
        function hexToRgb(hex) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return `${r}, ${g}, ${b}`;
        }
        
        function updateThemeColor(color) {
            themeColor = color;
            const rgb = hexToRgb(color);
            document.documentElement.style.setProperty('--theme-color', color);
            document.documentElement.style.setProperty('--theme-color-rgb', rgb);
            drawFretboard();
            drawPianoRoll();
        }
        
        // Audio Functions
        function initAudioContext() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                console.log('üîä Audio context initialized');
            }
        }
        
        function midiNoteToFrequency(midiNote) {
            // Convert MIDI note number to frequency in Hz
            // A4 (MIDI 69) = 440 Hz
            return 440 * Math.pow(2, (midiNote - 69) / 12);
        }
        
        function playNote(noteNumber, duration = 0.2) {
            if (!audioEnabled || !audioContext) return;
            
            try {
                const frequency = midiNoteToFrequency(noteNumber);
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.type = 'sine'; // Smooth sine wave tone
                oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
                
                // Envelope for natural sound
                gainNode.gain.setValueAtTime(0, audioContext.currentTime);
                gainNode.gain.linearRampToValueAtTime(0.3, audioContext.currentTime + 0.01); // Attack
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration); // Decay
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + duration);
            } catch (error) {
                console.warn('Audio playback error:', error);
            }
        }
        
        // MIDI Parsing
        function parseMidi(arrayBuffer) {
            try {
                console.log('üì• Parsing MIDI file, size:', arrayBuffer.byteLength, 'bytes');
                
                // Convert ArrayBuffer to base64 for midi-parser-js
                const bytes = new Uint8Array(arrayBuffer);
                console.log('   First 4 bytes:', Array.from(bytes.slice(0, 4)).map(b => String.fromCharCode(b)).join(''));
                
                let binary = '';
                const chunkSize = 0x8000; // Process in chunks to avoid call stack size exceeded
                for (let i = 0; i < bytes.length; i += chunkSize) {
                    const chunk = bytes.subarray(i, Math.min(i + chunkSize, bytes.length));
                    binary += String.fromCharCode.apply(null, chunk);
                }
                const base64 = btoa(binary);
                
                // Parse with midi-parser-js
                const midi = MidiParser.parse(base64);
                console.log('   MIDI parsed:', midi ? 'success' : 'failed');
                
                if (!midi || !midi.track) {
                    console.error('‚ùå Invalid MIDI data - no tracks found');
                    return [];
                }
                
                console.log('   Format:', midi.formatType, '| Tracks:', midi.tracks, '| Time Division:', midi.timeDivision);
                
                const notes = [];
                const ticksPerBeat = midi.timeDivision;
                let tempo = 500000; // Default tempo (microseconds per quarter note = 120 BPM)
                
                midi.track.forEach((track, trackIndex) => {
                    let currentTick = 0;
                    let trackNotes = 0;
                    
                    track.event.forEach(event => {
                        currentTick += event.deltaTime;
                        
                        // Check for tempo changes (meta event type 81)
                        if (event.type === 255 && event.metaType === 81 && event.data && event.data.length >= 3) {
                            const newTempo = (event.data[0] << 16) | (event.data[1] << 8) | event.data[2];
                            if (newTempo > 0) {
                                tempo = newTempo;
                                console.log('   Tempo change:', (60000000 / tempo).toFixed(1), 'BPM');
                            }
                        }
                        
                        // Note On events (type 9 with velocity > 0)
                        if (event.type === 9 && event.data && event.data.length >= 2 && event.data[1] > 0) {
                            const noteNumber = event.data[0];
                            const timeInSeconds = (currentTick / ticksPerBeat) * (tempo / 1000000);
                            notes.push({
                                name: noteToName(noteNumber, currentNotation),
                                number: noteNumber,
                                time: timeInSeconds
                            });
                            trackNotes++;
                        }
                    });
                    
                    console.log(`   Track ${trackIndex}: ${trackNotes} notes`);
                });
                
                const sorted = notes.sort((a, b) => a.time - b.time);
                console.log('‚úÖ Total notes extracted:', sorted.length);
                if (sorted.length > 0) {
                    console.log('   First note:', sorted[0].name, 'at', sorted[0].time.toFixed(2), 's');
                    console.log('   Last note:', sorted[sorted.length-1].name, 'at', sorted[sorted.length-1].time.toFixed(2), 's');
                    console.log('   Note range:', Math.min(...sorted.map(n => n.number)), '-', Math.max(...sorted.map(n => n.number)));
                }
                
                return sorted;
            } catch (error) {
                console.error('‚ùå MIDI parsing error:', error);
                return [];
            }
        }
        
        // Sample MIDI Data
        function generateSampleMidi(type) {
            const samples = {
                cmajor: [
                    { number: 60, time: 0 },    // C4
                    { number: 62, time: 0.5 },  // D4
                    { number: 64, time: 1.0 },  // E4
                    { number: 65, time: 1.5 },  // F4
                    { number: 67, time: 2.0 },  // G4
                    { number: 69, time: 2.5 },  // A4
                    { number: 71, time: 3.0 },  // B4
                    { number: 72, time: 3.5 }   // C5
                ],
                blues: [
                    { number: 60, time: 0 },    // C4
                    { number: 63, time: 0.5 },  // Eb4
                    { number: 65, time: 1.0 },  // F4
                    { number: 66, time: 1.5 },  // F#4
                    { number: 67, time: 2.0 },  // G4
                    { number: 70, time: 2.5 },  // Bb4
                    { number: 60, time: 3.0 }   // C4
                ],
                arpeggio: [
                    { number: 60, time: 0 },    // C4
                    { number: 64, time: 0.3 },  // E4
                    { number: 67, time: 0.6 },  // G4
                    { number: 72, time: 0.9 },  // C5
                    { number: 67, time: 1.2 },  // G4
                    { number: 64, time: 1.5 },  // E4
                    { number: 60, time: 1.8 }   // C4
                ],
                // Guitar arpeggios
                guitarCMajArp: [
                    { number: 48, time: 0 },    // C3
                    { number: 52, time: 0.3 },  // E3
                    { number: 55, time: 0.6 },  // G3
                    { number: 60, time: 0.9 },  // C4
                    { number: 64, time: 1.2 },  // E4
                    { number: 67, time: 1.5 },  // G4
                    { number: 72, time: 1.8 },  // C5
                    { number: 67, time: 2.1 },  // G4
                    { number: 64, time: 2.4 },  // E4
                    { number: 60, time: 2.7 },  // C4
                    { number: 55, time: 3.0 },  // G3
                    { number: 52, time: 3.3 }   // E3
                ],
                guitarGMajArp: [
                    { number: 55, time: 0 },    // G3
                    { number: 59, time: 0.3 },  // B3
                    { number: 62, time: 0.6 },  // D4
                    { number: 67, time: 0.9 },  // G4
                    { number: 71, time: 1.2 },  // B4
                    { number: 74, time: 1.5 },  // D5
                    { number: 71, time: 1.8 },  // B4
                    { number: 67, time: 2.1 },  // G4
                    { number: 62, time: 2.4 },  // D4
                    { number: 59, time: 2.7 }   // B3
                ],
                // Piano arpeggios
                pianoCMaj7Arp: [
                    { number: 48, time: 0 },    // C3
                    { number: 52, time: 0.25 }, // E3
                    { number: 55, time: 0.5 },  // G3
                    { number: 59, time: 0.75 }, // B3
                    { number: 60, time: 1.0 },  // C4
                    { number: 64, time: 1.25 }, // E4
                    { number: 67, time: 1.5 },  // G4
                    { number: 71, time: 1.75 }, // B4
                    { number: 72, time: 2.0 },  // C5
                    { number: 71, time: 2.25 }, // B4
                    { number: 67, time: 2.5 },  // G4
                    { number: 64, time: 2.75 }, // E4
                    { number: 60, time: 3.0 },  // C4
                    { number: 59, time: 3.25 }, // B3
                    { number: 55, time: 3.5 },  // G3
                    { number: 52, time: 3.75 }  // E3
                ],
                pianoAMinArp: [
                    { number: 57, time: 0 },    // A3
                    { number: 60, time: 0.25 }, // C4
                    { number: 64, time: 0.5 },  // E4
                    { number: 69, time: 0.75 }, // A4
                    { number: 72, time: 1.0 },  // C5
                    { number: 76, time: 1.25 }, // E5
                    { number: 72, time: 1.5 },  // C5
                    { number: 69, time: 1.75 }, // A4
                    { number: 64, time: 2.0 },  // E4
                    { number: 60, time: 2.25 }  // C4
                ],
                // Bass arpeggios
                bassCMajArp: [
                    { number: 36, time: 0 },    // C2
                    { number: 40, time: 0.4 },  // E2
                    { number: 43, time: 0.8 },  // G2
                    { number: 48, time: 1.2 },  // C3
                    { number: 43, time: 1.6 },  // G2
                    { number: 40, time: 2.0 },  // E2
                    { number: 36, time: 2.4 }   // C2
                ],
                bassFunkLine: [
                    { number: 40, time: 0 },    // E2
                    { number: 40, time: 0.25 }, // E2
                    { number: 43, time: 0.5 },  // G2
                    { number: 45, time: 0.75 }, // A2
                    { number: 47, time: 1.0 },  // B2
                    { number: 45, time: 1.25 }, // A2
                    { number: 43, time: 1.5 },  // G2
                    { number: 40, time: 1.75 }, // E2
                    { number: 38, time: 2.0 },  // D2
                    { number: 40, time: 2.5 }   // E2
                ],
                // Ukulele arpeggios
                ukuleleCMajArp: [
                    { number: 60, time: 0 },    // C4
                    { number: 64, time: 0.3 },  // E4
                    { number: 67, time: 0.6 },  // G4
                    { number: 72, time: 0.9 },  // C5
                    { number: 76, time: 1.2 },  // E5
                    { number: 72, time: 1.5 },  // C5
                    { number: 67, time: 1.8 },  // G4
                    { number: 64, time: 2.1 }   // E4
                ],
                ukuleleFMajArp: [
                    { number: 65, time: 0 },    // F4
                    { number: 69, time: 0.3 },  // A4
                    { number: 72, time: 0.6 },  // C5
                    { number: 77, time: 0.9 },  // F5
                    { number: 72, time: 1.2 },  // C5
                    { number: 69, time: 1.5 }   // A4
                ]
            };
            
            return samples[type].map(note => ({
                ...note,
                name: noteToName(note.number, currentNotation)
            }));
        }
        
        // Drawing Functions
        function drawFretboard() {
            const ctx = fretboardCanvas.getContext('2d');
            ctx.clearRect(0, 0, fretboardCanvas.width, fretboardCanvas.height);
            
            // Detect instrument type based on number of strings
            const numStrings = currentTuning.length;
            const isUkulele = (numStrings === 4 && currentTuning[0] > 50); // High tuning = ukulele
            const isBass = (numStrings === 4 || numStrings === 5) && currentTuning[0] < 35; // Low tuning = bass
            
            // Determine number of frets based on view mode
            const numFrets = currentFretView === 'extended' ? 23 : 12;
            const stringSpacing = isUkulele ? 40 : (isBass && numStrings === 5 ? 30 : 35); // Adjust spacing based on instrument
            const fretSpacing = currentFretView === 'extended' ? 35 : 55; // Narrower spacing for extended view
            const startX = 80;
            const startY = isUkulele ? 50 : (isBass && numStrings === 5 ? 50 : 60); // Adjust vertical position
            
            // Adjust canvas width for extended view
            if (currentFretView === 'extended') {
                fretboardCanvas.width = 900;
            } else {
                fretboardCanvas.width = 800;
            }
            
            // Adjust canvas height based on instrument
            if (isUkulele) {
                fretboardCanvas.height = 250;
            } else if (isBass && numStrings === 5) {
                fretboardCanvas.height = 280;
            } else if (isBass) {
                fretboardCanvas.height = 250;
            } else {
                fretboardCanvas.height = 350;
            }
            
            const stringOrder = currentStringOrder === 'lowBottom' 
                ? [...currentTuning].reverse() 
                : currentTuning;
            
            // Draw strings
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 1;
            for (let i = 0; i < numStrings; i++) {
                const y = startY + i * stringSpacing;
                ctx.beginPath();
                ctx.moveTo(startX, y);
                ctx.lineTo(startX + numFrets * fretSpacing, y);
                ctx.stroke();
            }
            
            // Draw frets
            ctx.strokeStyle = '#888';
            for (let f = 0; f <= numFrets; f++) {
                const x = startX + f * fretSpacing;
                ctx.lineWidth = f === 0 ? 3 : 1;
                ctx.beginPath();
                ctx.moveTo(x, startY);
                ctx.lineTo(x, startY + (numStrings - 1) * stringSpacing);
                ctx.stroke();
            }
            
            // Draw fret markers
            const markers = currentFretView === 'extended' 
                ? [3, 5, 7, 9, 12, 15, 17, 19, 21] 
                : [3, 5, 7, 9, 12];
            const markerSize = currentFretView === 'extended' ? 6 : 8;
            ctx.fillStyle = '#888';
            markers.forEach(fret => {
                const x = startX + (fret - 0.5) * fretSpacing;
                const y = startY + 2.5 * stringSpacing;
                ctx.beginPath();
                ctx.arc(x, y, markerSize, 0, Math.PI * 2);
                ctx.fill();
            });
            
            // Draw double dots for 12th and 24th fret in extended view
            if (currentFretView === 'extended') {
                [12, 24].forEach(fret => {
                    if (fret <= numFrets) {
                        const x = startX + (fret - 0.5) * fretSpacing;
                        const y1 = startY + 1.5 * stringSpacing;
                        const y2 = startY + 3.5 * stringSpacing;
                        ctx.beginPath();
                        ctx.arc(x, y1, markerSize, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.beginPath();
                        ctx.arc(x, y2, markerSize, 0, Math.PI * 2);
                        ctx.fill();
                    }
                });
            }
            
            // Draw fret numbers (above and below fretboard)
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 12px Roboto';
            ctx.textAlign = 'center';
            const fretboardBottom = startY + (numStrings - 1) * stringSpacing;
            for (let f = 0; f <= numFrets; f++) {
                const x = startX + f * fretSpacing;
                ctx.fillText(f.toString(), x, startY - 8);
                ctx.fillText(f.toString(), x, fretboardBottom + 20);
            }
            
            // Draw string labels
            ctx.font = 'bold 12px Roboto';
            ctx.textAlign = 'right';
            ctx.textBaseline = 'middle';
            stringOrder.forEach((noteNum, i) => {
                const y = startY + i * stringSpacing;
                const noteName = noteToName(noteNum, currentNotation);
                ctx.fillText(noteName, startX - 10, y);
            });
            
            // Draw active notes with heat map coloring, fret view filtering, and duplicate filtering
            ctx.strokeStyle = '#1a1a1a';
            ctx.lineWidth = 2;
            
            // If duplicate filtering is enabled, find the best position for each note
            const notesToDraw = new Map(); // noteNumber -> {string, fret, x, y}
            
            activeNotes.forEach(noteNumber => {
                const positions = [];
                
                // Find all possible positions for this note
                stringOrder.forEach((stringNote, stringIndex) => {
                    for (let fret = 0; fret <= numFrets; fret++) {
                        if (stringNote + fret === noteNumber) {
                            // Apply fret view filter
                            let showNote = true;
                            if (currentFretView === 'above6' && fret <= 6) {
                                showNote = false;
                            } else if (currentFretView === 'range6-13' && (fret < 6 || fret > 13)) {
                                showNote = false;
                            } else if (currentFretView === '0-6' && fret > 6) {
                                showNote = false;
                            }
                            
                            if (!showNote) continue;
                            
                            positions.push({
                                stringIndex,
                                fret,
                                x: startX + fret * fretSpacing,
                                y: startY + stringIndex * stringSpacing
                            });
                        }
                    }
                });
                
                // Choose which positions to draw based on duplicate filter setting
                if (currentDuplicateFilter === 'unique' && positions.length > 0) {
                    // Show only the lowest fret position (most practical for open positions)
                    const bestPosition = positions.reduce((best, current) => 
                        current.fret < best.fret ? current : best
                    );
                    notesToDraw.set(noteNumber, [bestPosition]);
                } else {
                    // Show all positions
                    notesToDraw.set(noteNumber, positions);
                }
            });
            
            // Draw the selected positions
            notesToDraw.forEach((positions, noteNumber) => {
                positions.forEach(pos => {
                    const x = pos.x;
                    const y = pos.y;
                    
                    // Heat map coloring based on intensity
                    const intensity = noteIntensity[noteNumber] || 1;
                    if (intensity < 1) {
                        // Heat map mode - color by frequency
                        const hue = 120 - (intensity * 120); // Green (120) to Red (0)
                        const saturation = 70 + (intensity * 30); // 70-100%
                        const lightness = 40 + (intensity * 20); // 40-60%
                        ctx.fillStyle = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
                    } else {
                        // Normal mode - use theme color
                        ctx.fillStyle = themeColor;
                    }
                    
                    ctx.beginPath();
                    ctx.arc(x, y, 12, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                    
                    // Draw note name
                    ctx.fillStyle = '#000';
                    ctx.font = 'bold 10px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    const noteName = noteToName(noteNumber, currentNotation).replace(/\d/, '');
                    ctx.fillText(noteName, x, y + 1);
                });
            });
        }
        
        function drawPianoRoll() {
            const ctx = pianoCanvas.getContext('2d');
            ctx.clearRect(0, 0, pianoCanvas.width, pianoCanvas.height);
            
            const whiteKeys = ['C', 'D', 'E', 'F', 'G', 'A', 'B'];
            const blackKeyOffsets = [0, 1, 3, 4, 5]; // Positions where black keys exist
            const numWhiteKeys = 21; // 3 octaves (C2-B4)
            const keyWidth = pianoCanvas.width / numWhiteKeys;
            const blackKeyHeight = pianoCanvas.height * 0.6;
            const startingOctave = 2; // Starting from C2 for 3-octave range (C2-B4)
            
            const themeColorRgb = hexToRgb(themeColor);
            
            // Draw white keys
            for (let i = 0; i < numWhiteKeys; i++) {
                const x = i * keyWidth;
                const note = whiteKeys[i % 7];
                const octave = startingOctave + Math.floor(i / 7);
                const noteNumber = (octave + 1) * 12 + [0, 2, 4, 5, 7, 9, 11][i % 7];
                
                // Gradient fill
                const grad = ctx.createLinearGradient(x, 0, x, pianoCanvas.height);
                grad.addColorStop(0, '#fafafa');
                grad.addColorStop(1, '#dcdcdc');
                ctx.fillStyle = grad;
                ctx.strokeStyle = '#444';
                ctx.lineWidth = 1;
                ctx.fillRect(x, 0, keyWidth, pianoCanvas.height);
                ctx.strokeRect(x, 0, keyWidth, pianoCanvas.height);
                
                // Highlight if active with heat map
                if (activeNotes.has(noteNumber)) {
                    const intensity = noteIntensity[noteNumber] || 1;
                    if (intensity < 1) {
                        // Heat map mode
                        const hue = 120 - (intensity * 120);
                        const saturation = 70 + (intensity * 30);
                        const lightness = 50 + (intensity * 20);
                        ctx.fillStyle = `hsla(${hue}, ${saturation}%, ${lightness}%, 0.7)`;
                    } else {
                        // Normal mode
                        ctx.fillStyle = `rgba(${themeColorRgb}, 0.4)`;
                    }
                    ctx.fillRect(x, 0, keyWidth, pianoCanvas.height);
                }
                
                // Label
                ctx.font = activeNotes.has(noteNumber) ? 'bold 11px Roboto' : '10px Roboto';
                ctx.fillStyle = activeNotes.has(noteNumber) ? themeColor : '#333';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'bottom';
                ctx.fillText(`${note}${octave}`, x + keyWidth / 2, pianoCanvas.height - 5);
            }
            
            // Draw black keys
            for (let i = 0; i < numWhiteKeys; i++) {
                const note = whiteKeys[i % 7];
                const octave = startingOctave + Math.floor(i / 7);
                
                if (blackKeyOffsets.includes(i % 7)) {
                    const x = (i + 1) * keyWidth - keyWidth / 4;
                    const semitone = ([0, 2, 4, 5, 7, 9, 11][i % 7] + 1) % 12;
                    const noteNumber = (octave + 1) * 12 + semitone;
                    
                    // Gradient fill
                    const grad = ctx.createLinearGradient(x - keyWidth / 4, 0, x - keyWidth / 4, blackKeyHeight);
                    grad.addColorStop(0, '#333');
                    grad.addColorStop(1, '#000');
                    ctx.fillStyle = grad;
                    ctx.strokeStyle = '#111';
                    ctx.fillRect(x - keyWidth / 4, 0, keyWidth / 2, blackKeyHeight);
                    ctx.strokeRect(x - keyWidth / 4, 0, keyWidth / 2, blackKeyHeight);
                    
                    // Highlight if active with heat map
                    if (activeNotes.has(noteNumber)) {
                        const intensity = noteIntensity[noteNumber] || 1;
                        if (intensity < 1) {
                            // Heat map mode
                            const hue = 120 - (intensity * 120);
                            const saturation = 70 + (intensity * 30);
                            const lightness = 50 + (intensity * 20);
                            ctx.fillStyle = `hsla(${hue}, ${saturation}%, ${lightness}%, 0.8)`;
                        } else {
                            // Normal mode
                            ctx.fillStyle = `rgba(${themeColorRgb}, 0.6)`;
                        }
                        ctx.fillRect(x - keyWidth / 4, 0, keyWidth / 2, blackKeyHeight);
                    }
                    
                    // Label
                    const blackNote = noteToName(noteNumber, currentNotation);
                    ctx.font = activeNotes.has(noteNumber) ? 'bold 10px Roboto' : '9px Roboto';
                    ctx.fillStyle = activeNotes.has(noteNumber) ? themeColor : '#eee';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'bottom';
                    ctx.fillText(blackNote, x, blackKeyHeight - 5);
                }
            }
        }
        
        // Playback Functions
        let lastPlayedNotes = new Set(); // Track which notes were played in the last frame
        
        function startPlayback() {
            if (isPlaying || midiNotes.length === 0) return;
            
            isPlaying = true;
            playBtn.disabled = true;
            pauseBtn.disabled = false;
            stopBtn.disabled = false;
            lastPlayedNotes.clear(); // Reset tracking
            
            const speed = parseFloat(speedSlider.value);
            const startTime = Date.now();
            const startPlaybackTime = playbackTime;
            
            playbackTimer = setInterval(() => {
                const elapsed = (Date.now() - startTime) / 1000;
                playbackTime = startPlaybackTime + elapsed * speed;
                
                // Clear previous active notes
                activeNotes.clear();
                
                // Find notes at current time (with tolerance)
                const currentNotes = midiNotes.filter(note => 
                    Math.abs(note.time - playbackTime) < 0.1
                );
                
                // Track which notes are new in this frame
                const newNotes = new Set();
                
                currentNotes.forEach(note => {
                    activeNotes.add(note.number);
                    
                    // Only play audio if this is a new note (not played in previous frame)
                    if (!lastPlayedNotes.has(note.number)) {
                        playNote(note.number, 0.3);
                        newNotes.add(note.number);
                        
                        const rangeWarning = getNoteRangeWarning(note.number);
                        const warningText = rangeWarning ? ` <span style="color: #ff6b6b">${rangeWarning}</span>` : '';
                        const info = `<span style="color: ${themeColor}">‚ô™</span> Note: ${note.name} (${note.number}) at ${playbackTime.toFixed(2)}s${warningText}<br>`;
                        midiInfo.innerHTML += info;
                        midiInfo.scrollTop = midiInfo.scrollHeight;
                    }
                });
                
                // Update the set of played notes for next frame
                lastPlayedNotes = new Set(activeNotes);
                
                // Update visualizations
                if (currentNotes.length > 0) {
                    drawFretboard();
                    drawPianoRoll();
                }
                
                // Check if playback finished
                if (playbackTime > midiNotes[midiNotes.length - 1].time + 1) {
                    if (isLooping) {
                        // Restart from beginning
                        console.log('üîÅ Looping playback - restarting');
                        clearInterval(playbackTimer);
                        playbackTime = 0;
                        activeNotes.clear();
                        midiInfo.innerHTML = '';
                        drawFretboard();
                        drawPianoRoll();
                        // Restart playback
                        setTimeout(() => startPlayback(), 100);
                    } else {
                        stopPlayback();
                    }
                }
            }, 50); // 20fps for smooth playback
        }
        
        function pausePlayback() {
            if (!isPlaying) return;
            
            clearInterval(playbackTimer);
            isPlaying = false;
            playBtn.disabled = false;
            pauseBtn.disabled = true;
            
            // Set currentStepIndex to the note at or just before current playback time
            // This allows users to step from the paused position
            for (let i = midiNotes.length - 1; i >= 0; i--) {
                if (midiNotes[i].time <= playbackTime) {
                    currentStepIndex = i;
                    break;
                }
            }
        }
        
        function stopPlayback() {
            clearInterval(playbackTimer);
            isPlaying = false;
            playbackTime = 0;
            currentStepIndex = 0;
            activeNotes.clear();
            lastPlayedNotes.clear(); // Reset audio tracking
            
            playBtn.disabled = false;
            pauseBtn.disabled = true;
            stopBtn.disabled = true;
            
            midiInfo.innerHTML = '';
            drawFretboard();
            drawPianoRoll();
        }
        
        function stepForward() {
            if (midiNotes.length === 0) return;
            
            // Stop any playback
            if (isPlaying) {
                pausePlayback();
            }
            
            // Move to next note
            if (currentStepIndex < midiNotes.length - 1) {
                currentStepIndex++;
            } else if (isLooping) {
                currentStepIndex = 0;
            }
            
            showStepNote();
        }
        
        function stepBackward() {
            if (midiNotes.length === 0) return;
            
            // Stop any playback
            if (isPlaying) {
                pausePlayback();
            }
            
            // Move to previous note
            if (currentStepIndex > 0) {
                currentStepIndex--;
            } else if (isLooping) {
                currentStepIndex = midiNotes.length - 1;
            }
            
            showStepNote();
        }
        
        function showStepNote() {
            const note = midiNotes[currentStepIndex];
            
            // Clear and show only current note
            activeNotes.clear();
            noteIntensity = {}; // Clear heat map
            activeNotes.add(note.number);
            
            // Play audio for this note
            playNote(note.number, 0.5);
            
            // Check if note is in range
            const rangeWarning = getNoteRangeWarning(note.number);
            
            // Update info display
            midiInfo.innerHTML = `
                <span style="color: ${themeColor}">üéµ Step Mode</span><br>
                <strong>Note ${currentStepIndex + 1} of ${midiNotes.length}</strong><br>
                Note: ${note.name} (MIDI ${note.number})<br>
                Time: ${note.time.toFixed(2)}s<br>
                ${rangeWarning ? `<span style="color: #ff6b6b">${rangeWarning}</span><br>` : ''}
                <small>Use Step Forward/Back to analyze each position</small>
            `;
            
            // Update visualizations
            drawFretboard();
            drawPianoRoll();
            
            console.log(`üéµ Step ${currentStepIndex + 1}/${midiNotes.length}: ${note.name} at ${note.time.toFixed(2)}s`);
        }
        
        // MIDI Analysis Functions
        function analyzeMidi(notes) {
            // Count note frequencies
            const noteFrequency = {};
            notes.forEach(note => {
                const pitch = note.number % 12; // Get pitch class (0-11)
                noteFrequency[pitch] = (noteFrequency[pitch] || 0) + 1;
            });
            
            // Define mode patterns (intervals from root)
            const modes = {
                'Major (Ionian)': [0, 2, 4, 5, 7, 9, 11],
                'Minor (Aeolian)': [0, 2, 3, 5, 7, 8, 10],
                'Dorian': [0, 2, 3, 5, 7, 9, 10],
                'Phrygian': [0, 1, 3, 5, 7, 8, 10],
                'Lydian': [0, 2, 4, 6, 7, 9, 11],
                'Mixolydian': [0, 2, 4, 5, 7, 9, 10],
                'Locrian': [0, 1, 3, 5, 6, 8, 10]
            };
            
            const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
            
            let bestMatch = { key: 'C', mode: 'Major (Ionian)', confidence: 0 };
            
            // Try each key and mode
            for (let root = 0; root < 12; root++) {
                for (const [modeName, pattern] of Object.entries(modes)) {
                    let score = 0;
                    let totalNotes = 0;
                    
                    // Calculate how well the notes match this key/mode
                    for (let i = 0; i < 12; i++) {
                        const freq = noteFrequency[i] || 0;
                        totalNotes += freq;
                        
                        // Check if this pitch is in the scale
                        const pitchInScale = pattern.includes((i - root + 12) % 12);
                        if (pitchInScale) {
                            score += freq;
                        }
                    }
                    
                    const confidence = totalNotes > 0 ? Math.round((score / totalNotes) * 100) : 0;
                    
                    if (confidence > bestMatch.confidence) {
                        bestMatch = {
                            key: noteNames[root],
                            mode: modeName,
                            confidence: confidence
                        };
                    }
                }
            }
            
            console.log('üéº Key/Mode Analysis:', bestMatch);
            return bestMatch;
        }
        
        function showHeatMap() {
            if (midiNotes.length === 0) return;
            
            console.log('üî• Generating heat map from', midiNotes.length, 'notes');
            
            // Count frequency of each note
            const noteFrequency = {};
            let maxFrequency = 0;
            
            midiNotes.forEach(note => {
                noteFrequency[note.number] = (noteFrequency[note.number] || 0) + 1;
                maxFrequency = Math.max(maxFrequency, noteFrequency[note.number]);
            });
            
            // Clear active notes and add with intensity
            activeNotes.clear();
            noteIntensity = {}; // Store intensity for heat map coloring
            
            Object.keys(noteFrequency).forEach(noteNum => {
                const num = parseInt(noteNum);
                activeNotes.add(num);
                // Normalize intensity 0-1
                noteIntensity[num] = noteFrequency[num] / maxFrequency;
            });
            
            console.log('   Heat map notes:', activeNotes.size);
            console.log('   Max frequency:', maxFrequency);
            
            // Update info display
            midiInfo.innerHTML = `<span style="color: ${themeColor}">üî• Heat Map: ${activeNotes.size} unique notes</span><br>`;
            midiInfo.innerHTML += `<small>Most played note: ${noteToName(parseInt(Object.keys(noteFrequency).reduce((a, b) => noteFrequency[a] > noteFrequency[b] ? a : b)), currentNotation)} (${maxFrequency} times)</small>`;
            
            // Draw visualizations with heat map
            drawFretboard();
            drawPianoRoll();
            
            statusMessage.style.color = themeColor;
        }
        
         function showAllNotes() {
            if (midiNotes.length === 0) return;
            
            console.log('üéµ Showing all', midiNotes.length, 'notes on fretboard');
            
            // Stop any playback
            if (isPlaying) {
                pausePlayback();
            }
            
            activeNotes.clear();
            noteIntensity = {}; // Clear heat map
            const uniqueNotes = new Set();
            const outOfRangeNotes = new Set();
            midiNotes.forEach(note => {
                activeNotes.add(note.number);
                uniqueNotes.add(note.number);
                if (!isNoteInRange(note.number)) {
                    outOfRangeNotes.add(note.number);
                }
            });
            
            console.log('   Unique notes:', uniqueNotes.size);
            console.log('   Note range:', Math.min(...uniqueNotes), '-', Math.max(...uniqueNotes));
            console.log('   Out of range notes:', outOfRangeNotes.size);
            
            // Update info display
            midiInfo.innerHTML = `<span style="color: ${themeColor}">Displaying all ${uniqueNotes.size} unique notes from MIDI file</span><br>`;
            const noteList = Array.from(uniqueNotes).sort((a, b) => a - b).map(n => noteToName(n, currentNotation)).join(', ');
            midiInfo.innerHTML += `Notes: ${noteList}<br>`;
            
            if (outOfRangeNotes.size > 0) {
                const outOfRangeList = Array.from(outOfRangeNotes).sort((a, b) => a - b).map(n => noteToName(n, currentNotation)).join(', ');
                midiInfo.innerHTML += `<span style="color: #ff6b6b">‚ö†Ô∏è ${outOfRangeNotes.size} notes out of range for current instrument: ${outOfRangeList}</span>`;
            }
            
            // Draw visualizations
            drawFretboard();
            drawPianoRoll();
            
            statusMessage.textContent = `Showing all ${uniqueNotes.size} unique notes`;
            statusMessage.style.color = themeColor;
        }
        
        // Event Handlers
        uploadBtn.addEventListener('click', () => {
            fileInput.click();
        });
        
        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            
            statusMessage.textContent = 'Loading MIDI file...';
            statusMessage.style.color = themeColor;
            
            const reader = new FileReader();
            reader.onload = (e) => {
                const arrayBuffer = e.target.result;
                
                midiNotes = parseMidi(arrayBuffer);
                
                if (midiNotes.length > 0) {
                    // Analyze MIDI for key/mode detection
                    const analysis = analyzeMidi(midiNotes);
                    
                    statusMessage.innerHTML = `
                        <strong>Loaded: ${file.name}</strong> (${midiNotes.length} notes)<br>
                        <span style="color: ${themeColor}">üéµ Detected: ${analysis.key} ${analysis.mode}</span> 
                        (${analysis.confidence}% confidence)<br>
                        <small>Heat map shows note frequency - brighter = played more often</small>
                    `;
                    statusMessage.style.color = '#fff';
                    showAllBtn.disabled = false;
                    playBtn.disabled = false;
                    loopBtn.disabled = false;
                    stepBackBtn.disabled = false;
                    stepForwardBtn.disabled = false;
                    speedSlider.disabled = false;
                    sampleSelect.value = '';
                    currentStepIndex = 0;
                    
                    // Update fretboard label with detected key/mode
                    fretboardLabel.textContent = `${analysis.key} ${analysis.mode} - Guitar Fretboard`;
                    
                    // Show heat map immediately
                    showHeatMap();
                } else {
                    statusMessage.textContent = 'Error: Could not parse MIDI file';
                    statusMessage.style.color = '#ff6b6b';
                }
            };
            reader.onerror = () => {
                statusMessage.textContent = 'Error loading MIDI file';
                statusMessage.style.color = '#ff6b6b';
            };
            reader.readAsArrayBuffer(file);
        });
        
        sampleSelect.addEventListener('change', async (e) => {
            if (!e.target.value) return;
            
            const sampleType = e.target.value;
            const sampleName = e.target.options[e.target.selectedIndex].text;
            
            // Check if this is a file-based sample or generated sample
            if (sampleType === 'toccata' || sampleType === 'bumblebee') {
                const filename = sampleType === 'toccata' 
                    ? 'toccata_and_fugue_in_d_minor.mid' 
                    : 'flight_of_the_bumblebee.mid';
                
                statusMessage.textContent = `Loading ${sampleName}...`;
                statusMessage.style.color = themeColor;
                
                try {
                    const response = await fetch(filename);
                    const arrayBuffer = await response.arrayBuffer();
                    
                    midiNotes = parseMidi(arrayBuffer);
                    
                    if (midiNotes.length > 0) {
                        const analysis = analyzeMidi(midiNotes);
                        
                        statusMessage.innerHTML = `
                            <strong>Loaded: ${sampleName}</strong> (${midiNotes.length} notes)<br>
                            <span style="color: ${themeColor}">üéµ Detected: ${analysis.key} ${analysis.mode}</span> 
                            (${analysis.confidence}% confidence)<br>
                            <small>Heat map shows note frequency - brighter = played more often</small>
                        `;
                        statusMessage.style.color = '#fff';
                        showAllBtn.disabled = false;
                        playBtn.disabled = false;
                        loopBtn.disabled = false;
                        stepBackBtn.disabled = false;
                        stepForwardBtn.disabled = false;
                        speedSlider.disabled = false;
                        currentStepIndex = 0;
                        
                        fretboardLabel.textContent = `${analysis.key} ${analysis.mode} - Guitar Fretboard`;
                        showHeatMap();
                    }
                } catch (error) {
                    console.error('Error loading sample:', error);
                    statusMessage.textContent = `Error loading ${sampleName}`;
                    statusMessage.style.color = '#ff6b6b';
                }
            } else {
                // Generated sample
                midiNotes = generateSampleMidi(sampleType);
                statusMessage.textContent = `Loaded sample: ${sampleName}`;
                statusMessage.style.color = themeColor;
                showAllBtn.disabled = false;
                playBtn.disabled = false;
                loopBtn.disabled = false;
                stepBackBtn.disabled = false;
                stepForwardBtn.disabled = false;
                speedSlider.disabled = false;
                currentStepIndex = 0;
            }
        });
        
        showAllBtn.addEventListener('click', showAllNotes);
        playBtn.addEventListener('click', startPlayback);
        pauseBtn.addEventListener('click', pausePlayback);
        stopBtn.addEventListener('click', stopPlayback);
        stepBackBtn.addEventListener('click', stepBackward);
        stepForwardBtn.addEventListener('click', stepForward);
        
        loopBtn.addEventListener('click', () => {
            isLooping = !isLooping;
            if (isLooping) {
                loopBtn.classList.add('active');
                console.log('üîÅ Loop enabled');
                statusMessage.textContent = 'Loop enabled';
                statusMessage.style.color = themeColor;
            } else {
                loopBtn.classList.remove('active');
                console.log('üîÅ Loop disabled');
                statusMessage.textContent = 'Loop disabled';
                statusMessage.style.color = themeColor;
            }
        });
        
        speedSlider.addEventListener('input', (e) => {
            const speed = parseFloat(e.target.value);
            speedDisplay.textContent = speed.toFixed(1) + 'x';
            
            if (isPlaying) {
                pausePlayback();
                startPlayback();
            }
        });
        
        notationSelect.addEventListener('change', (e) => {
            currentNotation = e.target.value;
            midiNotes = midiNotes.map(note => ({
                ...note,
                name: noteToName(note.number, currentNotation)
            }));
            drawFretboard();
            drawPianoRoll();
        });
        
        tuningSelect.addEventListener('change', (e) => {
            currentTuning = tunings[e.target.value];
            const numStrings = currentTuning.length;
            const isUkulele = (numStrings === 4 && currentTuning[0] > 50);
            const isBass = (numStrings === 4 || numStrings === 5) && currentTuning[0] < 35;
            const instrumentName = isUkulele ? 'Ukulele' : (isBass ? 'Bass' : 'Guitar');
            
            // Update fretboard label
            if (midiNotes.length > 0) {
                const currentLabel = fretboardLabel.textContent;
                if (currentLabel.includes('-')) {
                    // Has key/mode info, preserve it
                    const keyMode = currentLabel.split('-')[0].trim();
                    fretboardLabel.textContent = `${keyMode} - ${instrumentName} Fretboard`;
                } else {
                    fretboardLabel.textContent = `${instrumentName} Fretboard`;
                }
            } else {
                fretboardLabel.textContent = `${instrumentName} Fretboard`;
            }
            
            drawFretboard();
        });
        
        stringOrderSelect.addEventListener('change', (e) => {
            currentStringOrder = e.target.value;
            drawFretboard();
        });
        
        fretViewSelect.addEventListener('change', (e) => {
            currentFretView = e.target.value;
            console.log('üé∏ Fret view changed to:', currentFretView);
            drawFretboard();
        });
        
        duplicateFilterSelect.addEventListener('change', (e) => {
            currentDuplicateFilter = e.target.value;
            console.log('üé∏ Duplicate filter changed to:', currentDuplicateFilter);
            drawFretboard();
        });
        
        themeColorInput.addEventListener('input', (e) => {
            updateThemeColor(e.target.value);
        });
        
        // Initialize audio context on first user interaction (required by browsers)
        playBtn.addEventListener('click', () => {
            initAudioContext();
        }, { once: true });
        
        stepForwardBtn.addEventListener('click', () => {
            initAudioContext();
        }, { once: true });
        
        stepBackBtn.addEventListener('click', () => {
            initAudioContext();
        }, { once: true });
        
        // Initialize
        drawFretboard();
        drawPianoRoll();
    </script>
</body>
</html>
